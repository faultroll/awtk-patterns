# 基于MVVM开发的计算器

把MVP模式这些规律找出来进行抽象，通过一些规则在视图和模型建立联系，也就是数据绑定和命令绑定，就形成了MVVM模式。MVVM是Model-View-ViewModel简称。在MVVM中：

模型(Model)。模型还是MVC中的模型，这里不再赘述。

视图(View)。视图还是MVC中的视图，但它不需要向模型注册改变的事件通知了，这个由数据绑定去做了。

视图模型(ViewModel)。 ViewModel不是Controller也不是Presenter，视图模型是视图还是模型？按MVVM的发明者John Gossman的话说，视图模型是视图眼中的模型。放大镜下的虫子还是虫子，所以视图眼中的模型还是模型。视图模型与视图没有直接关系，是可以为之编写单元测试的。

呈现逻辑Presenter去哪里了？呈现逻辑从一行行代码变成了一条条数据绑定和命令绑定的规则，对规则的处理和解释成了MVVM框架或公用库，可以在多个项目中共享。

![](../../images/mvvm.png?raw=true)

MVVM模式有下列好处：

强制分离用户界面和业务逻辑。在MVC和MVP中，不能强制分离用户界面和业务逻辑，程序员的一念之间，就导致用户界面和业务逻辑混在一起。MVVM中不需要编写界面相关的代码，自然没有办法让用户界面和业务逻辑耦合到一起。

界面描述文件和程序代码之间具有更松的耦合。通常用XML或RC文件来描述界面，在MVC和MVP中，在界面上增加一个控件或删除一个控件，都会导致相应的代码需要修改。而在MVVM中，采用了面向意图的编程，界面上表现的只是一种意图，至于在程序中，谁去实现，怎么实现，甚至有没有实现，界面都是不关心的，所以界面和代码之间值的耦合是很松的。

不需要学习GUI的API。通过数据绑定和命令绑定建立视图和模型之间的联系。用声明式的规则取代命令式的代码，不需要写界面相关的代码，所以不需要学习GUI的API，无论是采用Qt还是AWTK，都用同样的方式开发。

视图模型和模型并不相同，之所以要引入视图模型，主要原因有：

模型中的数据有时并不适合直接显示在视图上。比如出版日期，在模型中是整数，直接显示出来，用户就看不懂，需要转换成人类可以理解的字符串。

模型中的一个数据项可能以多种形式呈现在视图上。比如出版日期，除了显示出版日期外，也可能把最近出版的书，显示一个新书标志。

视图中的输入数据和模型中的存储数据，它们的格式有时可能不同。比如出版日期，视图上输入的格式和模型里存储的格式就不一样。

视图需要视图模型提供数据校验规则来判断视图上的输入是否合法。

有些数据是有依赖关系的。比如在输入收货地址时，选择省份时，城市列表跟着变化。

有些状态不属于业务逻辑，但是需要保存下来。如为了支持撤销操作，需要保存命令历史记录。

在C/C++等静态语言中，没有办法通过函数的名称去调用对象的成员函数，也没有办法通过属性的名称去访问对象的成员变量。视图模型需要提供一种机制来实现这些功能，否则绑定规则就没法实现。

MVVM 的缺点。

内存问题。据说WPF内存开销很大，即使在PC上也大得让人无法忍受(常有人借此来反对MVVM)。WEB前端流行的MVVM框架，像React和Vue.js等，采用虚拟DOM的方式，内存需求可能有大幅度增加。

性能问题。MVVM通常的做法是，模型有变化时会刷新整个界面。如果采用虚拟DOM的方式，还需要重新构建一个虚拟DOM，与原来的虚拟DOM比较，性能开销就更大了。

调试问题。如果没有工具的协助，数据绑定会让调试变得困难。

以上这些问题在手机和PC上，已经不是什么大问题了，但对于嵌入式系统来说，仍然是难以跨越的障碍，所以目前几乎没有针对嵌入式平台开发的MVVM框架。



